/*tslint:disable*/
// Copyright 2017 The RLS Developers. See the COPYRIGHT
// file at the top-level directory of this distribution and at
// http://rust-lang.org/COPYRIGHT.
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const child_process = tslib_1.__importStar(require("child_process"));
const coc_nvim_1 = require("coc.nvim");
const fs = tslib_1.__importStar(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const vscode_uri_1 = tslib_1.__importDefault(require("vscode-uri"));
const configuration_1 = require("./configuration");
const rustup_1 = require("./rustup");
const spinner_1 = require("./spinner");
const tasks_1 = require("./tasks");
const child_process_1 = require("./utils/child_process");
let client;
function activate(context) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let file = yield coc_nvim_1.workspace.findUp('Cargo.toml');
        let folder = file == null ? null : path_1.default.dirname(file);
        folder = folder || coc_nvim_1.workspace.rootPath;
        warnOnMissingCargoToml(folder);
        client = new ClientWorkspace({
            uri: vscode_uri_1.default.file(folder).toString(),
            name: path_1.default.basename(folder)
        });
        client.start(context).catch(_e => {
            // noop
        });
    });
}
exports.activate = activate;
function deactivate() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield client.stop();
    });
}
exports.deactivate = deactivate;
// We run one RLS and one corresponding language client per workspace folder
// (VSCode workspace, not Cargo workspace). This class contains all the per-client
// and per-workspace stuff.
class ClientWorkspace {
    constructor(folder) {
        this.lc = null;
        this.config = configuration_1.RLSConfiguration.loadFromWorkspace(vscode_uri_1.default.parse(folder.uri).fsPath);
        this.folder = folder;
    }
    start(context) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // These methods cannot throw an error, so we can drop it.
            spinner_1.startSpinner('RLS', 'Starting');
            this.warnOnRlsToml();
            // Check for deprecated env vars.
            if (process.env.RLS_PATH || process.env.RLS_ROOT) {
                coc_nvim_1.workspace.showMessage('Found deprecated environment variables (RLS_PATH or RLS_ROOT). Use `rls.path` or `rls.root` settings.', 'warning');
            }
            const serverOptions = () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield this.autoUpdate();
                return this.makeRlsProcess();
            });
            const clientOptions = {
                // Register the server for Rust files
                documentSelector: [
                    { language: 'rust', scheme: 'file' },
                    { language: 'rust', scheme: 'untitled' }
                ],
                synchronize: { configurationSection: 'rust' },
                // Controls when to focus the channel rather than when to reveal it in the drop-down list
                revealOutputChannelOn: this.config.revealOutputChannelOn,
                initializationOptions: {
                    omitInitBuild: true,
                    cmdRun: true,
                },
                workspaceFolder: this.folder,
            };
            // Create the language client and start the client.
            this.lc = new coc_nvim_1.LanguageClient('rust', 'Rust Language Server', serverOptions, clientOptions);
            const promise = this.progressCounter();
            const disposable = this.lc.start();
            context.subscriptions.push(disposable);
            context.subscriptions.push(coc_nvim_1.services.registLanguageClient(this.lc));
            this.registerCommands(context);
            return promise;
        });
    }
    registerCommands(context) {
        if (!this.lc) {
            return;
        }
        const findImplsDisposable = coc_nvim_1.commands.registerCommand('rls.findImpls', () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.lc) {
                return;
            }
            yield this.lc.onReady();
            // Prior to https://github.com/rust-lang-nursery/rls/pull/936 we used a custom
            // LSP message - if the implementation provider is specified this means we can use the 3.6 one.
            const useLSPRequest = this.lc.initializeResult &&
                this.lc.initializeResult.capabilities.implementationProvider === true;
            const request = useLSPRequest ? vscode_languageserver_protocol_1.ImplementationRequest.type.method : 'rustDocument/implementations';
            const position = yield coc_nvim_1.workspace.getCursorPosition();
            const document = yield coc_nvim_1.workspace.document;
            if (!document || document.filetype !== 'rust') {
                return;
            }
            const params = {
                textDocument: {
                    uri: document.uri
                },
                position
            };
            let locations;
            try {
                locations = yield this.lc.sendRequest(request, params);
            }
            catch (reason) {
                coc_nvim_1.workspace.showMessage('find implementations failed: ' + reason, 'error');
                return;
            }
            return coc_nvim_1.commands.executeCommand('editor.action.showReferences', document.uri, position, locations);
        }));
        context.subscriptions.push(findImplsDisposable);
        const rustupUpdateDisposable = coc_nvim_1.commands.registerCommand('rls.update', () => {
            return rustup_1.rustupUpdate(this.config.rustupConfig());
        });
        context.subscriptions.push(rustupUpdateDisposable);
        const restartServer = coc_nvim_1.commands.registerCommand('rls.restart', () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.lc) {
                yield this.lc.stop();
            }
            return this.start(context);
        }));
        context.subscriptions.push(restartServer);
        context.subscriptions.push(coc_nvim_1.commands.registerCommand('rls.run', (cmd) => tasks_1.runCommand(coc_nvim_1.workspace.rootPath, cmd)));
    }
    progressCounter() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.lc) {
                return;
            }
            const runningProgress = new Set();
            const asPercent = (fraction) => `${Math.round(fraction * 100)}%`;
            let runningDiagnostics = 0;
            yield this.lc.onReady();
            spinner_1.stopSpinner('RLS');
            this.lc.onNotification(new vscode_languageserver_protocol_1.NotificationType('window/progress'), function (progress) {
                if (progress.done) {
                    runningProgress.delete(progress.id);
                }
                else {
                    runningProgress.add(progress.id);
                }
                if (runningProgress.size) {
                    let status = '';
                    if (typeof progress.percentage === 'number') {
                        status = asPercent(progress.percentage);
                    }
                    else if (progress.message) {
                        status = progress.message;
                    }
                    else if (progress.title) {
                        status = `[${progress.title.toLowerCase()}]`;
                    }
                    spinner_1.startSpinner('RLS', status);
                }
                else {
                    spinner_1.stopSpinner('RLS');
                }
            });
            // FIXME these are legacy notifications used by RLS ca jan 2018.
            // remove once we're certain we've progress on.
            this.lc.onNotification(new vscode_languageserver_protocol_1.NotificationType('rustDocument/beginBuild'), function (_f) {
                runningDiagnostics++;
                spinner_1.startSpinner('RLS', 'working');
            });
            this.lc.onNotification(new vscode_languageserver_protocol_1.NotificationType('rustDocument/diagnosticsEnd'), function (_f) {
                runningDiagnostics--;
                if (runningDiagnostics <= 0) {
                    spinner_1.stopSpinner('RLS');
                }
            });
        });
    }
    stop() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let promise = Promise.resolve(void 0);
            if (this.lc) {
                promise = this.lc.stop();
            }
            return promise.then(() => {
            });
        });
    }
    getSysroot(env) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let output;
            try {
                if (this.config.rustupDisabled) {
                    output = yield child_process_1.execFile('rustc', ['--print', 'sysroot'], { env });
                }
                else {
                    output = yield child_process_1.execFile(this.config.rustupPath, ['run', this.config.channel, 'rustc', '--print', 'sysroot'], { env });
                }
            }
            catch (e) {
                throw new Error(`Error getting sysroot from \`rustc\`: ${e}`);
            }
            if (!output.stdout) {
                throw new Error(`Couldn't get sysroot from \`rustc\`: Got no ouput`);
            }
            return output.stdout.replace('\n', '').replace('\r', '');
        });
    }
    // Make an evironment to run the RLS.
    // Tries to synthesise RUST_SRC_PATH for Racer, if one is not already set.
    makeRlsEnv(setLibPath = false) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const env = process.env;
            let sysroot;
            try {
                sysroot = yield this.getSysroot(env);
            }
            catch (err) {
                console.info(err.message);
                console.info(`Let's retry with extended $PATH`);
                env.PATH = `${env.HOME || '~'}/.cargo/bin:${env.PATH || ''}`;
                try {
                    sysroot = yield this.getSysroot(env);
                }
                catch (e) {
                    console.warn('Error reading sysroot (second try)', e);
                    coc_nvim_1.workspace.showMessage('RLS could not set RUST_SRC_PATH for Racer because it could not read the Rust sysroot.', 'warning');
                    return env;
                }
            }
            console.info(`Setting sysroot to`, sysroot);
            if (!process.env.RUST_SRC_PATH) {
                env.RUST_SRC_PATH = sysroot + '/lib/rustlib/src/rust/src';
            }
            if (setLibPath) {
                function appendEnv(envVar, newComponent) {
                    const old = process.env[envVar];
                    return old ? `${newComponent}:${old}` : newComponent;
                }
                env.DYLD_LIBRARY_PATH = appendEnv('DYLD_LIBRARY_PATH', sysroot + '/lib');
                env.LD_LIBRARY_PATH = appendEnv('LD_LIBRARY_PATH', sysroot + '/lib');
            }
            return env;
        });
    }
    makeRlsProcess() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Allow to override how RLS is started up.
            const rls_path = this.config.rlsPath;
            let childProcessPromise;
            if (rls_path) {
                const env = yield this.makeRlsEnv(true);
                console.info('running ' + rls_path);
                childProcessPromise = Promise.resolve(child_process.spawn(rls_path, [], { env }));
            }
            else if (this.config.rustupDisabled) {
                const env = yield this.makeRlsEnv(true);
                console.info('running ' + rls_path);
                childProcessPromise = Promise.resolve(child_process.spawn('rls', [], { env }));
            }
            else {
                const env = yield this.makeRlsEnv();
                console.info('running with rustup');
                childProcessPromise = rustup_1.runRlsViaRustup(env, this.config.rustupConfig());
            }
            try {
                const childProcess = yield childProcessPromise;
                childProcess.on('error', err => {
                    if (err.code == 'ENOENT') {
                        console.error('Could not spawn RLS process: ', err.message);
                        coc_nvim_1.workspace.showMessage('Could not start RLS', 'warning');
                    }
                    else {
                        throw err;
                    }
                });
                if (this.config.logToFile) {
                    const logPath = coc_nvim_1.workspace.rootPath + '/rls' + Date.now() + '.log';
                    const logStream = fs.createWriteStream(logPath, { flags: 'w+' });
                    logStream.on('open', function (_f) {
                        childProcess.stderr.addListener('data', function (chunk) {
                            logStream.write(chunk.toString());
                        });
                    }).on('error', function (err) {
                        console.error("Couldn't write to " + logPath + ' (' + err + ')');
                        logStream.end();
                    });
                }
                return childProcess;
            }
            catch (e) {
                spinner_1.stopSpinner('RLS could not be started');
                throw new Error('Error starting up rls.');
            }
        });
    }
    autoUpdate() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.config.updateOnStartup && !this.config.rustupDisabled) {
                yield rustup_1.rustupUpdate(this.config.rustupConfig());
            }
        });
    }
    warnOnRlsToml() {
        const tomlPath = coc_nvim_1.workspace.rootPath + '/rls.toml';
        fs.access(tomlPath, fs.constants.F_OK, (err) => {
            if (!err) {
                coc_nvim_1.workspace.showMessage(`Found deprecated rls.toml. Use Coc user settings instead, run ':CocConfig'`, 'warning');
            }
        });
    }
}
function warnOnMissingCargoToml(folder) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (!fs.existsSync(path_1.default.join(folder, 'Cargo.toml'))) {
            coc_nvim_1.workspace.showMessage('A Cargo.toml file must be at the root of the workspace in order to support all features', 'warning');
        }
    });
}
//# sourceMappingURL=index.js.map