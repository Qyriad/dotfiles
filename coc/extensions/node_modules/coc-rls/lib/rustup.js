// Copyright 2017 The RLS Developers. See the COPYRIGHT
// file at the top-level directory of this distribution and at
// http://rust-lang.org/COPYRIGHT.
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const child_process = tslib_1.__importStar(require("child_process"));
const coc_nvim_1 = require("coc.nvim");
const child_process_1 = require("./utils/child_process");
const spinner_1 = require("./spinner");
class RustupConfig {
    constructor(channel, path) {
        this.channel = channel;
        this.path = path;
    }
}
exports.RustupConfig = RustupConfig;
// This module handles running the RLS via rustup, including checking that rustup
// is installed and installing any required components/toolchains.
function runRlsViaRustup(env, config) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield ensureToolchain(config);
        yield checkForRls(config);
        return child_process.spawn(config.path, ['run', config.channel, 'rls'], { env });
    });
}
exports.runRlsViaRustup = runRlsViaRustup;
function rustupUpdate(config) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        spinner_1.startSpinner('RLS', 'Updating…');
        try {
            const { stdout } = yield child_process_1.execChildProcess(config.path + ' update');
            // This test is imperfect because if the user has multiple toolchains installed, they
            // might have one updated and one unchanged. But I don't want to go too far down the
            // rabbit hole of parsing rustup's output.
            if (stdout.indexOf('unchanged') > -1) {
                spinner_1.stopSpinner('Up to date.');
            }
            else {
                spinner_1.stopSpinner('Up to date. Restart extension for changes to take effect.');
            }
        }
        catch (e) {
            console.log(e);
            spinner_1.stopSpinner('An error occurred whilst trying to update.');
        }
    });
}
exports.rustupUpdate = rustupUpdate;
// Check for the nightly toolchain (and that rustup exists)
function ensureToolchain(config) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const toolchainInstalled = yield hasToolchain(config);
        if (toolchainInstalled) {
            return;
        }
        const confirmed = yield coc_nvim_1.workspace.showPrompt(config.channel + ' toolchain not installed. Install?');
        if (confirmed) {
            yield tryToInstallToolchain(config);
        }
        else {
            throw new Error();
        }
    });
}
function hasToolchain(config) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const { stdout } = yield child_process_1.execChildProcess(config.path + ' toolchain list');
            const hasToolchain = stdout.indexOf(config.channel) > -1;
            return hasToolchain;
        }
        catch (e) {
            console.log(e);
            // rustup not present
            coc_nvim_1.workspace.showMessage('Rustup not available. Install from https://www.rustup.rs/', 'error');
            throw e;
        }
    });
}
function tryToInstallToolchain(config) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        spinner_1.startSpinner('RLS', 'Installing toolchain…');
        try {
            const { stdout, stderr } = yield child_process_1.execChildProcess(config.path + ' toolchain install ' + config.channel);
            console.log(stdout);
            console.log(stderr);
            spinner_1.stopSpinner(config.channel + ' toolchain installed successfully');
        }
        catch (e) {
            console.log(e);
            coc_nvim_1.workspace.showMessage('Could not install ' + config.channel + ' toolchain', 'error');
            spinner_1.stopSpinner('Could not install ' + config.channel + ' toolchain');
            throw e;
        }
    });
}
// Check for rls components.
function checkForRls(config) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const hasRls = yield hasRlsComponents(config);
        if (hasRls) {
            return;
        }
        // missing component
        const confirmed = yield coc_nvim_1.workspace.showPrompt('RLS not installed. Install?');
        if (confirmed) {
            yield installRls(config);
        }
        else {
            throw new Error('RLS not installed');
        }
    });
}
function hasRlsComponents(config) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const { stdout } = yield child_process_1.execChildProcess(config.path + ' component list --toolchain ' + config.channel);
            const componentName = new RegExp('^rls.* \\((default|installed)\\)$', 'm');
            if (stdout.search(componentName) === -1 ||
                stdout.search(/^rust-analysis.* \((default|installed)\)$/m) === -1 ||
                stdout.search(/^rust-src.* \((default|installed)\)$/m) === -1) {
                return false;
            }
            else {
                return true;
            }
        }
        catch (e) {
            console.log(e);
            // rustup error?
            coc_nvim_1.workspace.showMessage('Unexpected error initialising RLS - error running rustup', 'error');
            throw e;
        }
    });
}
function installRls(config) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        spinner_1.startSpinner('RLS', 'Installing components…');
        const tryFn = (component) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { stdout, stderr, } = yield child_process_1.execChildProcess(config.path + ` component add ${component} --toolchain ` + config.channel);
                console.log(stdout);
                console.log(stderr);
                return null;
            }
            catch (_e) {
                coc_nvim_1.workspace.showMessage(`Could not install RLS component (${component})`, 'error');
                const err = new Error(`installing ${component} failed`);
                return err;
            }
        });
        {
            const e = yield tryFn('rust-analysis');
            if (e !== null) {
                spinner_1.stopSpinner('Could not install RLS');
                throw e;
            }
        }
        {
            const e = yield tryFn('rust-src');
            if (e !== null) {
                spinner_1.stopSpinner('Could not install RLS');
                throw e;
            }
        }
        console.log('install rls');
        {
            const e = yield tryFn('rls-preview');
            if (e !== null) {
                spinner_1.stopSpinner('Could not install RLS');
                throw e;
            }
        }
        spinner_1.stopSpinner('RLS components installed successfully');
    });
}
/**
 * Parses given output of `rustup show` and retrieves the local active toolchain.
 */
function parseActiveToolchain(rustupOutput) {
    // There may a default entry under 'installed toolchains' section, so search
    // for currently active/overridden one only under 'active toolchain' section
    const activeToolchainsIndex = rustupOutput.search('active toolchain');
    if (activeToolchainsIndex !== -1) {
        rustupOutput = rustupOutput.substr(activeToolchainsIndex);
        const matchActiveChannel = /^(\S*) \((?:default|overridden)/gm;
        const match = matchActiveChannel.exec(rustupOutput);
        if (match === null) {
            throw new Error(`couldn't find active toolchain under 'active toolchains'`);
        }
        else if (matchActiveChannel.exec(rustupOutput) !== null) {
            throw new Error(`multiple active toolchains found under 'active toolchains'`);
        }
        return match[1];
    }
    // Try matching the third line as the active toolchain
    const match = /^(?:.*\r?\n){2}(\S*) \((?:default|overridden)/.exec(rustupOutput);
    if (match !== null) {
        return match[1];
    }
    throw new Error(`couldn't find active toolchains`);
}
exports.parseActiveToolchain = parseActiveToolchain;
/**
 * Returns active (including local overrides) toolchain, as specified by rustup.
 * May throw if rustup at specified path can't be executed.
 */
function getActiveChannel(rustupPath, wsPath) {
    // rustup info might differ depending on where it's executed
    // (e.g. when a toolchain is locally overriden), so executing it
    // under our current workspace root should give us close enough result
    let activeChannel;
    try {
        // `rustup show active-toolchain` is available since rustup 1.12.0
        activeChannel = child_process.execSync(`${rustupPath} show active-toolchain`, { cwd: wsPath }).toString().trim();
    }
    catch (e) {
        // Possibly an old rustup version, so try rustup show
        const showOutput = child_process.execSync(`${rustupPath} show`, { cwd: wsPath }).toString();
        activeChannel = parseActiveToolchain(showOutput);
    }
    console.info(`Detected active channel: ${activeChannel} (since 'rust-client.channel' is unspecified)`);
    return activeChannel;
}
exports.getActiveChannel = getActiveChannel;
//# sourceMappingURL=rustup.js.map