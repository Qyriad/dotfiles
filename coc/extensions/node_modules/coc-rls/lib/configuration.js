// Copyright 2017 The RLS Developers. See the COPYRIGHT
// file at the top-level directory of this distribution and at
// http://rust-lang.org/COPYRIGHT.
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const coc_nvim_1 = require("coc.nvim");
const rustup_1 = require("./rustup");
function fromStringToRevealOutputChannelOn(value) {
    switch (value && value.toLowerCase()) {
        case 'info':
            return coc_nvim_1.RevealOutputChannelOn.Info;
        case 'warn':
            return coc_nvim_1.RevealOutputChannelOn.Warn;
        case 'error':
            return coc_nvim_1.RevealOutputChannelOn.Error;
        case 'never':
        default:
            return coc_nvim_1.RevealOutputChannelOn.Never;
    }
}
class RLSConfiguration {
    get rustupPath() {
        return this.configuration.get('rust-client.rustupPath', 'rustup');
    }
    get logToFile() {
        return this.configuration.get('rust-client.logToFile', false);
    }
    get rustupDisabled() {
        return this.configuration.get('rust-client.disableRustup', false);
    }
    get revealOutputChannelOn() {
        return RLSConfiguration.readRevealOutputChannelOn(this.configuration);
    }
    get updateOnStartup() {
        return this.configuration.get('rust-client.updateOnStartup', true);
    }
    get channel() {
        return RLSConfiguration.readChannel(this.rustupPath, this.configuration, this.wsPath);
    }
    /**
     * If specified, RLS will be spawned by executing a file at the given path.
     */
    get rlsPath() {
        // Path to the rls. Prefer `rust-client.rlsPath` if present, otherwise consider
        // the depreacted `rls.path` setting.
        const rlsPath = this.configuration.get('rls.path', null);
        if (rlsPath) {
            console.warn('`rls.path` has been deprecated; prefer `rust-client.rlsPath`');
        }
        const rustClientRlsPath = this.configuration.get('rust-client.rlsPath', null);
        if (!rustClientRlsPath) {
            return rlsPath;
        }
        return rustClientRlsPath;
    }
    static loadFromWorkspace(wsPath) {
        const configuration = coc_nvim_1.workspace.getConfiguration();
        return new RLSConfiguration(configuration, wsPath);
    }
    constructor(configuration, wsPath) {
        this.configuration = configuration;
        this.wsPath = wsPath;
    }
    rustupConfig() {
        return new rustup_1.RustupConfig(this.channel, this.rustupPath);
    }
    static readRevealOutputChannelOn(configuration) {
        const setting = configuration.get('rust-client.revealOutputChannelOn', 'never');
        return fromStringToRevealOutputChannelOn(setting);
    }
    /**
     * Tries to fetch the `rust-client.channel` configuration value. If missing,
     * falls back on active toolchain specified by rustup (at `rustupPath`),
     * finally defaulting to `nightly` if all fails.
     */
    static readChannel(rustupPath, configuration, wsPath) {
        let channel = configuration.get('rust-client.channel', null);
        if (channel != null) {
            return channel;
        }
        else {
            try {
                channel = rustup_1.getActiveChannel(rustupPath, wsPath);
                return channel;
            }
            // rustup might not be installed at the time the configuration is
            // initially loaded, so silently ignore the error and return a default value
            catch (e) {
                return 'nightly';
            }
        }
    }
}
exports.RLSConfiguration = RLSConfiguration;
//# sourceMappingURL=configuration.js.map