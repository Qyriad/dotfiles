"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const coc_nvim_1 = require("coc.nvim");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const vscode_uri_1 = tslib_1.__importDefault(require("vscode-uri"));
const typeConverters = tslib_1.__importStar(require("./utils/typeConverters"));
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const modules_1 = require("./utils/modules");
const helper_1 = require("./utils/helper");
class ReloadProjectsCommand {
    constructor(client) {
        this.client = client;
        this.id = 'tsserver.reloadProjects';
    }
    execute() {
        this.client.reloadProjects();
        coc_nvim_1.workspace.showMessage('projects reloaded');
    }
}
exports.ReloadProjectsCommand = ReloadProjectsCommand;
class OpenTsServerLogCommand {
    constructor(client) {
        this.client = client;
        this.id = 'tsserver.openTsServerLog';
    }
    execute() {
        this.client.serviceClient.openTsServerLogFile(); // tslint:disable-line
    }
}
exports.OpenTsServerLogCommand = OpenTsServerLogCommand;
class TypeScriptGoToProjectConfigCommand {
    constructor(client) {
        this.client = client;
        this.id = 'tsserver.goToProjectConfig';
    }
    execute() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let doc = yield coc_nvim_1.workspace.document;
            yield goToProjectConfig(this.client, doc.uri);
        });
    }
}
exports.TypeScriptGoToProjectConfigCommand = TypeScriptGoToProjectConfigCommand;
function goToProjectConfig(clientHost, uri) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (!clientHost.handles(uri)) {
            coc_nvim_1.workspace.showMessage('Could not determine TypeScript or JavaScript project. Unsupported file type', 'warning');
            return;
        }
        const client = clientHost.serviceClient;
        const file = client.toPath(uri);
        let res;
        try {
            res = yield client.execute('projectInfo', { file, needFileNameList: false }, vscode_languageserver_protocol_1.CancellationToken.None);
        }
        catch (_a) {
            // noop
        }
        if (!res || !res.body) {
            coc_nvim_1.workspace.showMessage('Could not determine TypeScript or JavaScript project.', 'warning');
            return;
        }
        const { configFileName } = res.body;
        if (configFileName && !isImplicitProjectConfigFile(configFileName)) {
            yield coc_nvim_1.workspace.openResource(vscode_uri_1.default.file(configFileName).toString());
            return;
        }
        coc_nvim_1.workspace.showMessage('Config file not found', 'warning');
    });
}
function isImplicitProjectConfigFile(configFileName) {
    return configFileName.indexOf('/dev/null/') === 0;
}
const autoFixableDiagnosticCodes = new Set([
    2420,
    2552,
    2304,
]);
class AutoFixCommand {
    constructor(client) {
        this.client = client;
        this.id = 'tsserver.executeAutofix';
    }
    execute() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let document = yield coc_nvim_1.workspace.document;
            if (!this.client.handles(document.uri)) {
                coc_nvim_1.workspace.showMessage('Document is not handled by tsserver.', 'warning');
                return;
            }
            let file = this.client.serviceClient.toPath(document.uri);
            let diagnostics = coc_nvim_1.diagnosticManager.getDiagnostics(document.uri);
            let missingDiagnostics = diagnostics.filter(o => o.code == 2307);
            if (missingDiagnostics.length) {
                let names = missingDiagnostics.map(o => {
                    let ms = o.message.match(/module\s'(.+)'\./);
                    return ms ? ms[1] : null;
                });
                names = names.filter(s => s != null);
                if (names.length) {
                    modules_1.installModules(document.uri, names).catch(e => {
                        console.error(e.message); // tslint:disable-line
                    });
                }
            }
            diagnostics = diagnostics.filter(x => autoFixableDiagnosticCodes.has(x.code));
            if (diagnostics.length == 0)
                return;
            diagnostics = diagnostics.reduce((arr, curr) => {
                if (curr.code == 2304 && arr.findIndex(o => o.message == curr.message) != -1)
                    return arr;
                arr.push(curr);
                return arr;
            }, []);
            let client = this.client.serviceClient;
            let edits = [];
            let command;
            let names = [];
            for (let diagnostic of diagnostics) {
                const args = Object.assign({}, typeConverters.Range.toFileRangeRequestArgs(file, diagnostic.range), { errorCodes: [+(diagnostic.code)] });
                const response = yield client.execute('getCodeFixes', args);
                if (response.type !== 'response' || !response.body || response.body.length < 1) {
                    if (diagnostic.code == 2304) {
                        let { range } = diagnostic;
                        let line = document.getline(range.start.line);
                        let name = line.slice(range.start.character, range.end.character);
                        if (helper_1.nodeModules.indexOf(name) !== -1 && names.indexOf(name) == -1) {
                            names.push(name);
                            edits.push({
                                range: vscode_languageserver_types_1.Range.create(0, 0, 0, 0),
                                newText: `import ${name} from '${name}'\n`
                            });
                            command = 'tsserver.organizeImports';
                        }
                    }
                    continue;
                }
                const fix = response.body[0];
                for (let change of fix.changes) {
                    if (change.fileName != file)
                        continue;
                    // change.fileName
                    for (let ch of change.textChanges) {
                        edits.push({
                            range: typeConverters.Range.fromTextSpan(ch),
                            newText: ch.newText
                        });
                    }
                }
            }
            if (edits.length)
                yield document.applyEdits(coc_nvim_1.workspace.nvim, edits);
            if (command)
                yield coc_nvim_1.commands.executeCommand(command);
        });
    }
}
exports.AutoFixCommand = AutoFixCommand;
class ConfigurePluginCommand {
    constructor(pluginManager) {
        this.pluginManager = pluginManager;
        this.id = '_typescript.configurePlugin';
    }
    execute(pluginId, configuration) {
        this.pluginManager.setConfiguration(pluginId, configuration);
    }
}
exports.ConfigurePluginCommand = ConfigurePluginCommand;
//# sourceMappingURL=commands.js.map