"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const child_process_1 = require("child_process");
const coc_nvim_1 = require("coc.nvim");
const find_up_1 = tslib_1.__importDefault(require("find-up"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const readline_1 = tslib_1.__importDefault(require("readline"));
const vscode_uri_1 = tslib_1.__importDefault(require("vscode-uri"));
const which_1 = tslib_1.__importDefault(require("which"));
const fs_2 = require("../utils/fs");
const TSC = './node_modules/.bin/tsc';
const countRegex = /Found\s+(\d+)\s+error/;
const errorRegex = /^(.+)\((\d+),(\d+)\):\s(\w+)\sTS(\d+):\s*(.+)$/;
var TscStatus;
(function (TscStatus) {
    TscStatus[TscStatus["INIT"] = 0] = "INIT";
    TscStatus[TscStatus["COMPILING"] = 1] = "COMPILING";
    TscStatus[TscStatus["RUNNING"] = 2] = "RUNNING";
    TscStatus[TscStatus["ERROR"] = 3] = "ERROR";
})(TscStatus || (TscStatus = {}));
class WatchCommand {
    constructor() {
        this.id = 'tsserver.watchBuild';
        this.isRunning = false;
        this.statusItem = coc_nvim_1.workspace.createStatusBarItem(1, { progress: true });
    }
    onStop() {
        let { nvim } = coc_nvim_1.workspace;
        this.isRunning = false;
        nvim.setVar('Tsc_running', 0, true);
        this.statusItem.hide();
    }
    onStart() {
        this.statusItem.text = 'compiling';
        this.statusItem.isProgress = true;
        this.statusItem.show();
        coc_nvim_1.workspace.nvim.call('setqflist', [[], 'r'], true);
    }
    start(cmd, args, cwd) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.isRunning) {
                this.process.kill();
                yield wait(200);
            }
            this.isRunning = true;
            coc_nvim_1.workspace.nvim.setVar('Tsc_running', 1, true);
            this.process = child_process_1.spawn(cmd, args, { cwd });
            this.process.on('error', e => {
                coc_nvim_1.workspace.showMessage(e.message, 'error');
            });
            const rl = readline_1.default.createInterface(this.process.stdout);
            this.process.on('exit', () => {
                this.onStop();
                rl.close();
            });
            this.process.stderr.on('data', chunk => {
                coc_nvim_1.workspace.showMessage(chunk.toString('utf8'), 'error');
            });
            const startTexts = ['Starting compilation in watch mode', 'Starting incremental compilation'];
            rl.on('line', line => {
                if (countRegex.test(line)) {
                    let ms = line.match(countRegex);
                    this.statusItem.text = ms[1] == '0' ? '✓' : '✗';
                    this.statusItem.isProgress = false;
                }
                else if (startTexts.findIndex(s => line.indexOf(s) !== -1) != -1) {
                    this.onStart();
                }
                else {
                    let ms = line.match(errorRegex);
                    if (!ms)
                        return;
                    let fullpath = path_1.default.join(cwd, ms[1]);
                    let uri = vscode_uri_1.default.file(fullpath).toString();
                    let doc = coc_nvim_1.workspace.getDocument(uri);
                    let bufnr = doc ? doc.bufnr : null;
                    let item = {
                        filename: fullpath,
                        lnum: Number(ms[2]),
                        col: Number(ms[3]),
                        text: `[tsc ${ms[5]}] ${ms[6]}`,
                        type: /error/i.test(ms[4]) ? 'E' : 'W'
                    };
                    if (bufnr)
                        item.bufnr = bufnr;
                    coc_nvim_1.workspace.nvim.call('setqflist', [[item], 'a']);
                }
            });
        });
    }
    execute() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let docs = coc_nvim_1.workspace.documents;
            let idx = docs.findIndex(doc => doc.uri.indexOf(TSC) !== -1);
            if (idx !== -1)
                return;
            let document = yield coc_nvim_1.workspace.document;
            let fsPath = vscode_uri_1.default.parse(document.uri).fsPath;
            let cwd = path_1.default.dirname(fsPath);
            let res = find_up_1.default.sync(['node_modules'], { cwd });
            let cmd;
            let root;
            if (!res) {
                if (executable('tsc')) {
                    cmd = 'tsc';
                    root = coc_nvim_1.workspace.cwd;
                }
            }
            else {
                let file = path_1.default.join(path_1.default.dirname(res), 'node_modules/.bin/tsc');
                if (fs_1.default.existsSync(file)) {
                    cmd = './node_modules/.bin/tsc';
                    root = path_1.default.dirname(res);
                }
            }
            if (!cmd) {
                coc_nvim_1.workspace.showMessage(`Local & global tsc not found`, 'error');
                return;
            }
            let configRoot = fs_2.resolveRoot(cwd, ['tsconfig.json']);
            if (!configRoot) {
                coc_nvim_1.workspace.showMessage('tsconfig.json not found!', 'error');
                return;
            }
            let configPath = path_1.default.relative(root, path_1.default.join(configRoot, 'tsconfig.json'));
            this.start(cmd, ['-p', configPath, '--watch', 'true', '--pretty', 'false'], root);
        });
    }
}
class WatchProject {
    constructor(commandManager) {
        this.disposables = [];
        let cmd = new WatchCommand();
        commandManager.register(cmd);
        let { nvim } = coc_nvim_1.workspace;
        nvim.getVar('Tsc_running').then(running => {
            if (running) {
                cmd.execute().catch(e => {
                    coc_nvim_1.workspace.showMessage('TSC:' + e.message, 'error');
                });
            }
        });
    }
    dispose() {
        coc_nvim_1.disposeAll(this.disposables);
    }
}
exports.default = WatchProject;
function executable(command) {
    try {
        which_1.default.sync(command);
    }
    catch (e) {
        return false;
    }
    return true;
}
function wait(ms) {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve();
        }, ms);
    });
}
//# sourceMappingURL=watchBuild.js.map